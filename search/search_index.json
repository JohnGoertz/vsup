{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VSUP: Value-Suppressing Uncertainty Palettes","text":"<p>A Python package for visualizing data with uncertainty using Value-Suppressing Uncertainty Palettes (VSUPs). Inspired by https://github.com/uwdata/vsup.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install vsup\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>The project is developed with uv.</p> <p>To check for a local python environment, run:</p> <pre><code>uv run python\n</code></pre> <p>Also install the pre-commit hooks with:</p> <pre><code>uv tool install pre-commit\npre-commit install\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>from vsup import VSUP\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a grid of values and uncertainties for better visualization\nn_points = 50\nstep = 1 / n_points\nvalues = np.linspace(step / 2, 1 - step / 2, n_points)\nuncertainties = np.linspace(step / 2, 1 - step / 2, n_points)\n\n# Create a 2D grid\nvalues, uncertainties = np.meshgrid(values, uncertainties)\n\n# Colorize the data\naxs = plt.subplots(3, 3, figsize=(9, 9))[1]\n\nfor row, quantization in zip(axs, [None, \"linear\", \"tree\"]):\n    for ax, mode in zip(row, [\"us\", \"ul\", \"usl\"]):\n        vsup = VSUP(palette=\"flare\", mode=mode, quantization=quantization)\n\n        colors = vsup(values, uncertainties)\n        ax.pcolormesh(values, uncertainties, colors)\n        # ax.set_title(f\"{mode}\")  #\\n({description})\")\n        ax.set_xlabel(\"Value\")\n        ax.set_ylabel(\"Uncertainty\")\n</code></pre>"},{"location":"#example","title":"Example","text":""},{"location":"#features","title":"Features","text":"<ul> <li>Three visualization modes:</li> <li>USL: Uncertainty mapped to Saturation (chroma) and Lightness</li> <li>US: Uncertainty mapped to Saturation</li> <li>UL: Uncertainty mapped to Lightness</li> <li>Two quantization mods:</li> <li>Linear: independent binning of values and uncertainties</li> <li>Tree: value bins depend on uncertainty bin: lower uncertainty, higher value resolution</li> <li>Support for any matplotlib and seaborn colormaps</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use this package in your research, please cite the original VSUP paper:</p> <pre><code>@inproceedings{2018-uncertainty-palettes,\n title = {Value-Suppressing Uncertainty Palettes},\n author = {Michael Correll AND Dominik Moritz AND Jeffrey Heer},\n booktitle = {ACM Human Factors in Computing Systems (CHI)},\n year = {2018},\n url = {http://idl.cs.washington.edu/papers/uncertainty-palettes},\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"api/quantization/","title":"quantization","text":"<p>handler: python   options:     show_root_heading: false     show_source: false</p>"},{"location":"api/quantization/#vsup.quantization--quantization-functions-for-vsup","title":"Quantization functions for VSUP.","text":"<p>This module provides functions for quantizing value and uncertainty pairs into discrete levels for visualization. Quantization is an important step in VSUP that helps reduce the complexity of the visualization while maintaining the essential patterns in the data.</p> <p>The module provides two quantization strategies:</p> <ol> <li>Linear quantization: Independently bins values and uncertainties into    equal-width intervals. This is simpler but may not capture the relationship    between value and uncertainty.</li> <li>Tree quantization: Uses a hierarchical approach where the number of value    bins depends on the uncertainty level. Higher uncertainty means fewer value    bins, reflecting the reduced confidence in precise value distinctions.</li> </ol>"},{"location":"api/quantization/#vsup.quantization.linear_quantization","title":"<code>linear_quantization(n_levels)</code>","text":"<p>Create a linear quantization function that bins both value and uncertainty into n_levels discrete levels.</p> <p>This function creates a quantizer that independently divides both the value and uncertainty ranges into n_levels equal-width bins. This is the simplest form of quantization and treats value and uncertainty as independent variables.</p> <p>Parameters:</p> Name Type Description Default <code>n_levels</code> <code>int</code> <p>Number of quantization levels for both value and uncertainty. Must be &gt;= 2.</p> required <p>Returns:</p> Type Description <code>function</code> <p>A function that takes (value, uncertainty) arrays and returns quantized versions with values in [0, 1] range.</p> Notes <p>The returned function performs the following steps: 1. Creates equal-width bins for both value and uncertainty 2. Assigns each input to its corresponding bin 3. Normalizes the bin indices to [0, 1] range</p> Source code in <code>vsup/quantization.py</code> <pre><code>def linear_quantization(n_levels: int):\n    \"\"\"\n    Create a linear quantization function that bins both value and uncertainty\n    into n_levels discrete levels.\n\n    This function creates a quantizer that independently divides both the value\n    and uncertainty ranges into n_levels equal-width bins. This is the simplest\n    form of quantization and treats value and uncertainty as independent variables.\n\n    Parameters\n    ----------\n    n_levels : int\n        Number of quantization levels for both value and uncertainty.\n        Must be &gt;= 2.\n\n    Returns\n    -------\n    function\n        A function that takes (value, uncertainty) arrays and returns\n        quantized versions with values in [0, 1] range.\n\n    Notes\n    -----\n    The returned function performs the following steps:\n    1. Creates equal-width bins for both value and uncertainty\n    2. Assigns each input to its corresponding bin\n    3. Normalizes the bin indices to [0, 1] range\n    \"\"\"\n\n    def quantize(\n        value: np.ndarray, uncertainty: np.ndarray\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Quantize value and uncertainty arrays into n_levels bins.\n\n        Parameters\n        ----------\n        value : array-like\n            Array of values to quantize. Should be in [0, 1] range.\n        uncertainty : array-like\n            Array of uncertainty values to quantize. Should be in [0, 1] range.\n\n        Returns\n        -------\n        tuple\n            (quantized_value, quantized_uncertainty) arrays with values in [0, 1] range.\n            The quantization preserves the relative ordering of values while\n            reducing the number of distinct levels.\n        \"\"\"\n        # Ensure inputs are numpy arrays\n        value = np.asarray(value)\n        uncertainty = np.asarray(uncertainty)\n\n        # Create bins for both value and uncertainty\n        # The bins are equal-width intervals in [0, 1]\n        value_bins = np.linspace(0, 1, n_levels + 1)\n        uncertainty_bins = np.linspace(0, 1, n_levels + 1)\n\n        # Quantize value and uncertainty into bins\n        # digitize returns the index of the bin for each value\n        quantized_value = np.digitize(value, value_bins) - 1\n        quantized_uncertainty = np.digitize(uncertainty, uncertainty_bins) - 1\n\n        # Ensure values are in [0, n_levels-1]\n        quantized_value = np.clip(quantized_value, 0, n_levels - 1)\n        quantized_uncertainty = np.clip(quantized_uncertainty, 0, n_levels - 1)\n\n        # Normalize to [0, 1] range for color mapping\n        quantized_value = quantized_value / (n_levels - 1)\n        quantized_uncertainty = quantized_uncertainty / (n_levels - 1)\n\n        return quantized_value, quantized_uncertainty\n\n    return quantize\n</code></pre>"},{"location":"api/quantization/#vsup.quantization.tree_quantization","title":"<code>tree_quantization(branching, layers)</code>","text":"<p>Create a tree quantization function that bins value and uncertainty into branching^layers discrete levels.</p> <p>This function creates a quantizer that uses a hierarchical approach where the number of value bins depends on the uncertainty level. Higher uncertainty means fewer value bins, reflecting the reduced confidence in precise value distinctions. This approach better captures the relationship between value and uncertainty.</p> <p>Parameters:</p> Name Type Description Default <code>branching</code> <code>int</code> <p>Number of branches at each node. This determines how many value bins are created for each uncertainty level.</p> required <code>layers</code> <code>int</code> <p>Number of layers in the tree. This determines the number of uncertainty levels and the maximum number of value bins (branching^(layers-1)).</p> required <p>Returns:</p> Type Description <code>function</code> <p>A function that takes (value, uncertainty) arrays and returns quantized versions with values in [0, 1] range.</p> Notes <p>The returned function performs the following steps: 1. Divides uncertainty range into 'layers' levels 2. For each uncertainty level, creates branching^(layers-1-level) value bins 3. Assigns values to bins based on their uncertainty level 4. Normalizes the results to [0, 1] range</p> Source code in <code>vsup/quantization.py</code> <pre><code>def tree_quantization(branching: int, layers: int):\n    \"\"\"\n    Create a tree quantization function that bins value and uncertainty\n    into branching^layers discrete levels.\n\n    This function creates a quantizer that uses a hierarchical approach where\n    the number of value bins depends on the uncertainty level. Higher uncertainty\n    means fewer value bins, reflecting the reduced confidence in precise value\n    distinctions. This approach better captures the relationship between value\n    and uncertainty.\n\n    Parameters\n    ----------\n    branching : int\n        Number of branches at each node. This determines how many value bins\n        are created for each uncertainty level.\n    layers : int\n        Number of layers in the tree. This determines the number of uncertainty\n        levels and the maximum number of value bins (branching^(layers-1)).\n\n    Returns\n    -------\n    function\n        A function that takes (value, uncertainty) arrays and returns\n        quantized versions with values in [0, 1] range.\n\n    Notes\n    -----\n    The returned function performs the following steps:\n    1. Divides uncertainty range into 'layers' levels\n    2. For each uncertainty level, creates branching^(layers-1-level) value bins\n    3. Assigns values to bins based on their uncertainty level\n    4. Normalizes the results to [0, 1] range\n    \"\"\"\n\n    def quantize(\n        value: np.ndarray, uncertainty: np.ndarray\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Quantize value and uncertainty arrays using a tree structure.\n\n        Parameters\n        ----------\n        value : array-like\n            Array of values to quantize. Should be in [0, 1] range.\n        uncertainty : array-like\n            Array of uncertainty values to quantize. Should be in [0, 1] range.\n\n        Returns\n        -------\n        tuple\n            (quantized_value, quantized_uncertainty) arrays with values in [0, 1] range.\n            The quantization preserves the relationship between value and uncertainty,\n            with higher uncertainty leading to coarser value quantization.\n        \"\"\"\n        # Ensure inputs are numpy arrays\n        value = np.asarray(value)\n        uncertainty = np.asarray(uncertainty)\n\n        # Create bins for uncertainty\n        # Divide uncertainty range into 'layers' levels\n        uncertainty_bins = np.linspace(0, 1, layers + 1)\n\n        # Quantize uncertainty into layers\n        uncertainty_level = np.digitize(uncertainty, uncertainty_bins) - 1\n        uncertainty_level = np.clip(uncertainty_level, 0, layers - 1)\n\n        # For each uncertainty level, calculate number of value bins\n        # Higher uncertainty means fewer value bins\n        # For level i, we have branching^(layers-1-i) bins\n        value_bins_per_level = branching ** (layers - 1 - uncertainty_level)\n\n        # Initialize output arrays\n        quantized_value = np.zeros_like(value)\n        quantized_uncertainty = np.zeros_like(uncertainty)\n\n        # Process each uncertainty level separately\n        for level in range(layers):\n            # Get mask for current uncertainty level\n            mask = uncertainty_level == level\n\n            if np.any(mask):\n                # Calculate number of bins for this uncertainty level\n                n_bins = value_bins_per_level[mask][0]  # Same for all in this level\n\n                # Create value bins for this uncertainty level\n                # We use [:-1] to exclude the right edge of the last bin\n                value_bins = np.linspace(0, 1, n_bins + 1)[:-1]\n\n                # Quantize values for this uncertainty level\n                # We subtract 0.5 to center the values in their bins\n                quantized_value[mask] = (\n                    np.digitize(value[mask], value_bins) - 0.5\n                ) / n_bins\n                quantized_uncertainty[mask] = level\n\n        # Normalize uncertainty to [0, 1] range for color mapping\n        quantized_uncertainty = quantized_uncertainty / (layers - 1)\n\n        return quantized_value, quantized_uncertainty\n\n    return quantize\n</code></pre>"},{"location":"api/transforms/","title":"transforms","text":"<p>handler: python   options:     show_root_heading: false     show_source: false</p>"},{"location":"api/transforms/#vsup.transforms--color-transformation-functions-for-vsup","title":"Color transformation functions for VSUP.","text":"<p>This module provides functions for converting between different color spaces and applying uncertainty-based transformations to colors using CIELAB color space. The transformations modify the color properties (saturation/chroma and lightness) based on the uncertainty value, making it easier to understand the reliability of the data while maintaining the ability to distinguish values.</p> <p>The module provides three transformation modes:</p> <ol> <li>USL: Uncertainty affects both saturation and lightness</li> <li>US: Uncertainty affects saturation only</li> <li>UL: Uncertainty affects lightness only</li> </ol>"},{"location":"api/transforms/#vsup.transforms.ul_transform","title":"<code>ul_transform(colors, uncertainty, lmax=1.0)</code>","text":"<p>Transform colors by mapping uncertainty to lightness only.</p> <p>This function modifies the input colors based on uncertainty by: 1. Keeping saturation (chroma) constant 2. Increasing lightness as uncertainty increases</p> <p>The transformation is performed in CIELAB color space, which provides better perceptual uniformity than RGB or HSV.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>array - like</code> <p>Input RGB colors in range [0, 1]</p> required <code>uncertainty</code> <code>array - like</code> <p>Uncertainty values in range [0, 1]</p> required <code>lmax</code> <code>float</code> <p>Maximum lightness (0 to 1). The maximum lightness will be 100 * lmax. Controls how white the colors become at high uncertainty. Default is 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Transformed RGB colors in range [0, 1]</p> Source code in <code>vsup/transforms.py</code> <pre><code>def ul_transform(\n    colors: np.ndarray, uncertainty: np.ndarray, lmax: float = 1.0\n) -&gt; np.ndarray:\n    \"\"\"\n    Transform colors by mapping uncertainty to lightness only.\n\n    This function modifies the input colors based on uncertainty by:\n    1. Keeping saturation (chroma) constant\n    2. Increasing lightness as uncertainty increases\n\n    The transformation is performed in CIELAB color space, which provides\n    better perceptual uniformity than RGB or HSV.\n\n    Parameters\n    ----------\n    colors : array-like\n        Input RGB colors in range [0, 1]\n    uncertainty : array-like\n        Uncertainty values in range [0, 1]\n    lmax : float, optional\n        Maximum lightness (0 to 1). The maximum lightness will be 100 * lmax.\n        Controls how white the colors become at high uncertainty.\n        Default is 1.0.\n\n    Returns\n    -------\n    np.ndarray\n        Transformed RGB colors in range [0, 1]\n    \"\"\"\n    lab_colors = color.rgb2lab(colors[..., :3])\n\n    # Adjust lightness (L*) - move towards white (100 * lmax) as uncertainty increases\n    max_lightness = 100 * lmax\n    lab_colors[..., 0] = (\n        lab_colors[..., 0] * (1 - uncertainty) + max_lightness * uncertainty\n    )\n\n    return color.lab2rgb(lab_colors)\n</code></pre>"},{"location":"api/transforms/#vsup.transforms.us_transform","title":"<code>us_transform(colors, uncertainty, smin=0.0)</code>","text":"<p>Transform colors by mapping uncertainty to saturation only.</p> <p>This function modifies the input colors based on uncertainty by: 1. Reducing saturation (chroma) as uncertainty increases 2. Keeping lightness constant</p> <p>The transformation is performed in CIELAB color space, which provides better perceptual uniformity than RGB or HSV.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>array - like</code> <p>Input RGB colors in range [0, 1]</p> required <code>uncertainty</code> <code>array - like</code> <p>Uncertainty values in range [0, 1]</p> required <code>smin</code> <code>float</code> <p>Minimum saturation/chroma (0 to 1). Higher values ensure colors remain visible even at high uncertainty. Default is 0.0.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Transformed RGB colors in range [0, 1]</p> Source code in <code>vsup/transforms.py</code> <pre><code>def us_transform(\n    colors: np.ndarray, uncertainty: np.ndarray, smin: float = 0.0\n) -&gt; np.ndarray:\n    \"\"\"\n    Transform colors by mapping uncertainty to saturation only.\n\n    This function modifies the input colors based on uncertainty by:\n    1. Reducing saturation (chroma) as uncertainty increases\n    2. Keeping lightness constant\n\n    The transformation is performed in CIELAB color space, which provides\n    better perceptual uniformity than RGB or HSV.\n\n    Parameters\n    ----------\n    colors : array-like\n        Input RGB colors in range [0, 1]\n    uncertainty : array-like\n        Uncertainty values in range [0, 1]\n    smin : float, optional\n        Minimum saturation/chroma (0 to 1). Higher values ensure colors\n        remain visible even at high uncertainty. Default is 0.0.\n\n    Returns\n    -------\n    np.ndarray\n        Transformed RGB colors in range [0, 1]\n    \"\"\"\n    lab_colors = color.rgb2lab(colors[..., :3])\n\n    # Scale down chroma (a* and b*) based on uncertainty, but keep above smin\n    chroma_scale = smin + (1 - smin) * (1 - uncertainty[..., np.newaxis])\n    lab_colors[..., 1:] *= chroma_scale\n\n    return color.lab2rgb(lab_colors)\n</code></pre>"},{"location":"api/transforms/#vsup.transforms.usl_transform","title":"<code>usl_transform(colors, uncertainty, smin=0.0, lmax=1.0)</code>","text":"<p>Transform colors by mapping uncertainty to both saturation and lightness.</p> <p>This function modifies the input colors based on uncertainty by: 1. Reducing saturation (chroma) as uncertainty increases 2. Increasing lightness as uncertainty increases</p> <p>The transformation is performed in CIELAB color space, which provides better perceptual uniformity than RGB or HSV.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>array - like</code> <p>Input RGB colors in range [0, 1]</p> required <code>uncertainty</code> <code>array - like</code> <p>Uncertainty values in range [0, 1]</p> required <code>smin</code> <code>float</code> <p>Minimum saturation/chroma (0 to 1). Higher values ensure colors remain visible even at high uncertainty. Default is 0.0.</p> <code>0.0</code> <code>lmax</code> <code>float</code> <p>Maximum lightness (0 to 1). The maximum lightness will be 100 * lmax. Controls how white the colors become at high uncertainty. Default is 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Transformed RGB colors in range [0, 1]</p> Source code in <code>vsup/transforms.py</code> <pre><code>def usl_transform(\n    colors: np.ndarray, uncertainty: np.ndarray, smin: float = 0.0, lmax: float = 1.0\n) -&gt; np.ndarray:\n    \"\"\"\n    Transform colors by mapping uncertainty to both saturation and lightness.\n\n    This function modifies the input colors based on uncertainty by:\n    1. Reducing saturation (chroma) as uncertainty increases\n    2. Increasing lightness as uncertainty increases\n\n    The transformation is performed in CIELAB color space, which provides\n    better perceptual uniformity than RGB or HSV.\n\n    Parameters\n    ----------\n    colors : array-like\n        Input RGB colors in range [0, 1]\n    uncertainty : array-like\n        Uncertainty values in range [0, 1]\n    smin : float, optional\n        Minimum saturation/chroma (0 to 1). Higher values ensure colors\n        remain visible even at high uncertainty. Default is 0.0.\n    lmax : float, optional\n        Maximum lightness (0 to 1). The maximum lightness will be 100 \\* lmax.\n        Controls how white the colors become at high uncertainty.\n        Default is 1.0.\n\n    Returns\n    -------\n    np.ndarray\n        Transformed RGB colors in range [0, 1]\n    \"\"\"\n    lab_colors = color.rgb2lab(colors[..., :3])\n\n    # Scale down chroma (a* and b*) based on uncertainty, but keep above smin\n    chroma_scale = smin + (1 - smin) * (1 - uncertainty[..., np.newaxis])\n    lab_colors[..., 1:] *= chroma_scale\n\n    # Adjust lightness (L*) - move towards white (100 * lmax) as uncertainty increases\n    max_lightness = 100 * lmax\n    lab_colors[..., 0] = (\n        lab_colors[..., 0] * (1 - uncertainty) + max_lightness * uncertainty\n    )\n\n    return color.lab2rgb(lab_colors)\n</code></pre>"},{"location":"api/vsup/","title":"vsup","text":"<p>handler: python   options:     show_root_heading: true     show_source: false</p>"},{"location":"api/vsup/#vsup.vsup--value-suppressing-uncertainty-palettes-vsup-for-visualizing-data-with-uncertainty","title":"Value-Suppressing Uncertainty Palettes (VSUP) for visualizing data with uncertainty.","text":"<p>This module provides a class for creating and using VSUPs to visualize data with uncertainty by mapping both value and uncertainty to color properties. VSUPs are a visualization technique that encodes both the value and its uncertainty in a single color, making it easier to understand the reliability of the data while maintaining the ability to distinguish values.</p> <p>The module supports three visualization modes:</p> <ul> <li>USL: Uncertainty mapped to both Saturation and Lightness</li> <li>US: Uncertainty mapped to Saturation only</li> <li>UL: Uncertainty mapped to Lightness only</li> </ul> <p>Note that transformations take place in the CIELAB color space: L-modes increase L* (lightness), while S-modes decrease \"chroma\": a* (green-red) and b* (blue-yellow), equally.</p> <p>It also provides two quantization methods:</p> <ul> <li>Linear: Independent binning of values and uncertainties</li> <li>Tree: Value bins depend on uncertainty level (higher uncertainty = fewer value bins)</li> </ul>"},{"location":"api/vsup/#vsup.vsup.VSUP","title":"<code>VSUP</code>","text":"<p>Value-Suppressing Uncertainty Palette (VSUP).</p> <p>A class that combines quantization, scaling, and colorizing to create uncertainty-aware color mappings. VSUPs encode both value and uncertainty information in a single color, making it easier to understand the reliability of the data while maintaining the ability to distinguish values.</p> <p>The class supports three visualization modes: - USL: Uncertainty affects both saturation and lightness - US: Uncertainty affects saturation only - UL: Uncertainty affects lightness only</p> <p>Parameters:</p> Name Type Description Default <code>palette</code> <code>str | Colormap</code> <p>Name of the palette to use (default: 'viridis'). Can be any matplotlib or seaborn colormap name.</p> <code>'viridis'</code> <code>mode</code> <code>(usl, us, ul)</code> <p>Visualization mode to use: - 'usl': Uncertainty mapped to Saturation and Lightness (default) - 'us': Uncertainty mapped to Saturation - 'ul': Uncertainty mapped to Lightness</p> <code>'usl'</code> <code>quantization</code> <code>(linear, tree, None)</code> <p>Type of quantization to use (default: 'linear'): - 'linear': Independent binning of values and uncertainties - 'tree': Value bins depend on uncertainty level - None: No quantization (continuous/256-bit color mapping)</p> <code>'linear'</code> <code>n_levels</code> <code>int</code> <p>Number of quantization levels for both value and uncertainty. Must be &gt;= 2. Default is 5.</p> <code>5</code> <code>tree_base</code> <code>int</code> <p>Branching factor for tree quantization (default: 2). Only used when quantization='tree'.</p> <code>2</code> <code>vmin</code> <code>float</code> <p>Minimum value for colormapping. If None, will be set to min of first input.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum value for colormapping. If None, will be set to max of first input.</p> <code>None</code> <code>umin</code> <code>float</code> <p>Minimum uncertainty for colormapping. If None, will be set to min of first input.</p> <code>None</code> <code>umax</code> <code>float</code> <p>Maximum uncertainty for colormapping. If None, will be set to max of first input.</p> <code>None</code> <code>smin</code> <code>float</code> <p>Minimum saturation/chroma (0 to 1). Default is 0.2. Higher values ensure colors remain visible even at high uncertainty.</p> <code>0.2</code> <code>lmax</code> <code>float</code> <p>Maximum lightness (0 to 1). The maximum lightness will be 100 * lmax. Default is 0.9. Controls how white the colors become at high uncertainty.</p> <code>0.9</code> Source code in <code>vsup/vsup.py</code> <pre><code>class VSUP:\n    \"\"\"\n    Value-Suppressing Uncertainty Palette (VSUP).\n\n    A class that combines quantization, scaling, and colorizing to create\n    uncertainty-aware color mappings. VSUPs encode both value and uncertainty\n    information in a single color, making it easier to understand the reliability\n    of the data while maintaining the ability to distinguish values.\n\n    The class supports three visualization modes:\n    - USL: Uncertainty affects both saturation and lightness\n    - US: Uncertainty affects saturation only\n    - UL: Uncertainty affects lightness only\n\n    Parameters\n    ----------\n    palette : str | matplotlib.colors.Colormap, optional\n        Name of the palette to use (default: 'viridis'). Can be any matplotlib\n        or seaborn colormap name.\n    mode : {'usl', 'us', 'ul'}, optional\n        Visualization mode to use:\n        - 'usl': Uncertainty mapped to Saturation and Lightness (default)\n        - 'us': Uncertainty mapped to Saturation\n        - 'ul': Uncertainty mapped to Lightness\n    quantization : {'linear', 'tree', None}, optional\n        Type of quantization to use (default: 'linear'):\n        - 'linear': Independent binning of values and uncertainties\n        - 'tree': Value bins depend on uncertainty level\n        - None: No quantization (continuous/256-bit color mapping)\n    n_levels : int, optional\n        Number of quantization levels for both value and uncertainty.\n        Must be &gt;= 2. Default is 5.\n    tree_base : int, optional\n        Branching factor for tree quantization (default: 2). Only used when\n        quantization='tree'.\n    vmin : float, optional\n        Minimum value for colormapping. If None, will be set to min of first input.\n    vmax : float, optional\n        Maximum value for colormapping. If None, will be set to max of first input.\n    umin : float, optional\n        Minimum uncertainty for colormapping. If None, will be set to min of first input.\n    umax : float, optional\n        Maximum uncertainty for colormapping. If None, will be set to max of first input.\n    smin : float, optional\n        Minimum saturation/chroma (0 to 1). Default is 0.2. Higher values ensure\n        colors remain visible even at high uncertainty.\n    lmax : float, optional\n        Maximum lightness (0 to 1). The maximum lightness will be 100 \\* lmax.\n        Default is 0.9. Controls how white the colors become at high uncertainty.\n    \"\"\"\n\n    def __init__(\n        self,\n        palette: Union[str, mcolors.Colormap] = \"viridis\",\n        mode: Literal[\"usl\", \"us\", \"ul\"] = \"usl\",\n        quantization: Literal[None, \"linear\", \"tree\"] = \"linear\",\n        n_levels: Optional[int] = 5,\n        tree_base: int = 2,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        umin: Optional[float] = None,\n        umax: Optional[float] = None,\n        smin: float = 0.2,\n        lmax: float = 0.9,\n    ):\n        # Validate input parameters\n        if mode not in [\"usl\", \"us\", \"ul\"]:\n            raise ValueError(\"mode must be one of 'usl', 'us', or 'ul'\")\n        if quantization not in [None, \"linear\", \"tree\"]:\n            raise ValueError(\"quantization must be one of None, 'linear', or 'tree'\")\n        if not 0 &lt;= smin &lt;= 1:\n            raise ValueError(\"smin must be between 0 and 1\")\n        if not 0 &lt;= lmax &lt;= 1:\n            raise ValueError(\"lmax must be between 0 and 1\")\n        if n_levels is not None:\n            if not isinstance(n_levels, int):\n                raise TypeError(\"n_levels must be an integer\")\n            if n_levels &lt; 2:\n                raise ValueError(\"n_levels must be &gt;= 2 if not None\")\n\n        # Store configuration parameters\n        self.quantization = quantization\n        self.mode = mode\n        self.n_levels = n_levels\n        self.tree_base = tree_base\n\n        # Create or use colormap\n        if isinstance(palette, str):\n            if n_levels is None:\n                self.cmap = sns.color_palette(palette, as_cmap=True)\n            else:\n                if quantization == \"linear\":\n                    self.cmap = sns.color_palette(palette, as_cmap=True)\n                else:\n                    self.cmap = sns.color_palette(palette, as_cmap=True)\n        elif isinstance(palette, mcolors.Colormap):\n            self.cmap = palette\n        else:\n            raise TypeError(\n                \"colormap must be a string or matplotlib.colors.Colormap object\"\n            )\n\n        # Store range parameters for normalization\n        self.vmin = vmin\n        self.vmax = vmax\n        self.umin = umin\n        self.umax = umax\n        self.smin = smin\n        self.lmax = lmax\n\n        # Set up quantization function based on configuration\n        if n_levels is None or quantization is None:\n            self.quantize = lambda v, u: (v, u)  # No quantization\n        elif quantization == \"linear\":\n            self.quantize = linear_quantization(n_levels)\n        else:  # tree\n            self.quantize = tree_quantization(tree_base, n_levels)\n\n    def _normalize(\n        self, value: np.ndarray, uncertainty: np.ndarray\n    ) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Normalize values and uncertainties to [0,1] range.\n\n        This internal method handles the normalization of input values and uncertainties\n        to the [0,1] range based on the configured min/max values. If min/max values\n        are not set, they are determined from the input data.\n\n        Parameters\n        ----------\n        value : np.ndarray\n            Array of values to normalize\n        uncertainty : np.ndarray\n            Array of uncertainty values to normalize\n\n        Returns\n        -------\n        Tuple[np.ndarray, np.ndarray]\n            Normalized value and uncertainty arrays in [0,1] range\n        \"\"\"\n        # Set ranges if not already set\n        if self.vmin is None:\n            self.vmin = np.min(value)\n        if self.vmax is None:\n            self.vmax = np.max(value)\n        if self.umin is None:\n            self.umin = np.min(uncertainty)\n        if self.umax is None:\n            self.umax = np.max(uncertainty)\n\n        # Normalize to [0,1]\n        norm_value = (value - self.vmin) / (self.vmax - self.vmin)\n        norm_uncertainty = (uncertainty - self.umin) / (self.umax - self.umin)\n\n        return norm_value, norm_uncertainty\n\n    def __call__(self, value: np.ndarray, uncertainty: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Map values and uncertainties to colors.\n\n        This method is the main interface for converting value-uncertainty pairs\n        to colors. It handles the complete pipeline:\n        1. Normalization of inputs to [0,1] range\n        2. Quantization of values and uncertainties\n        3. Base color mapping using the configured colormap\n        4. Uncertainty-based color modifications\n\n        Parameters\n        ----------\n        value : array-like\n            Array of values to map. Can be of any dimension.\n        uncertainty : array-like\n            Array of uncertainty values to map. Must have the same shape as value.\n\n        Returns\n        -------\n        np.ndarray\n            Array of RGB colors with shape (..., 3) where ... represents the input array shape.\n            For example, if input is shape (10, 20), output will be (10, 20, 3).\n            If input is shape (5, 6, 7), output will be (5, 6, 7, 3).\n\n        Raises\n        ------\n        ValueError\n            If value and uncertainty arrays have different shapes\n        \"\"\"\n        # Convert inputs to numpy arrays\n        value = np.atleast_1d(value)\n        uncertainty = np.atleast_1d(uncertainty)\n\n        # Validate input shapes\n        if value.shape != uncertainty.shape:\n            raise ValueError(\n                f\"value and uncertainty must have the same shape. Got value shape {value.shape} and uncertainty shape {uncertainty.shape}\"\n            )\n\n        # Store original shape for reshaping later\n        original_shape = value.shape\n\n        # Normalize values to [0,1] range\n        norm_value, norm_uncertainty = self._normalize(value, uncertainty)\n\n        # Quantize the normalized inputs\n        quantized_value, quantized_uncertainty = self.quantize(\n            norm_value, norm_uncertainty\n        )\n\n        # Get base colors from the colormap\n        base_colors = self.cmap(quantized_value)\n\n        # Apply uncertainty-based modifications with min/max constraints\n        if self.mode == \"usl\":\n            colors = usl_transform(\n                base_colors, quantized_uncertainty, smin=self.smin, lmax=self.lmax\n            )\n        elif self.mode == \"us\":\n            colors = us_transform(base_colors, quantized_uncertainty, smin=self.smin)\n        else:  # ul\n            colors = ul_transform(base_colors, quantized_uncertainty, lmax=self.lmax)\n\n        # Ensure output has correct shape (original shape + 3 for RGB)\n        if colors.shape != original_shape + (3,):\n            raise ValueError(\n                f\"Returned colors had shape {colors.shape}, expected {original_shape + (3,)}\"\n            )\n\n        return colors\n\n    def create_simple_legend(\n        self,\n        ax: Optional[plt.Axes] = None,\n        n_samples: int = 5,\n        size: float = 1.0,\n        title: str = \"Value\",\n        label_format: str = \"{:.1f}\",\n    ) -&gt; Tuple[plt.Axes, plt.Axes]:\n        \"\"\"\n        Create a simple legend showing value colors with uncertainty levels.\n\n        This method creates a basic legend that demonstrates how colors change\n        with both value and uncertainty. It shows:\n        1. A row of color samples for different values (with no uncertainty)\n        2. A column of color samples showing how uncertainty affects a middle value\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot the legend on. If None, a new figure is created.\n        n_samples : int, optional\n            Number of value samples to show (default: 5). These are evenly\n            spaced across the value range.\n        size : float, optional\n            Size of the legend elements (default: 1.0). This is a multiplier\n            for the default scatter point size.\n        title : str, optional\n            Title for the legend (default: \"Value\")\n        label_format : str, optional\n            Format string for value labels (default: \"{:.1f}\"). This controls\n            how the value numbers are displayed.\n\n        Returns\n        -------\n        tuple\n            (main_ax, legend_ax) containing the main plot axes and legend axes.\n            These are the same axes object since this is a simple legend.\n        \"\"\"\n        raise NotImplementedError(\"Simple legend not implemented yet\")\n        if ax is None:\n            fig, ax = plt.subplots(figsize=(6, 4))\n\n        # Create value samples - evenly spaced across the range\n        values = np.linspace(0, 1, n_samples)\n        uncertainties = np.zeros_like(values)  # Start with no uncertainty\n\n        # Create legend elements - row of value samples\n        for i, (v, u) in enumerate(zip(values, uncertainties)):\n            # Get color for this value-uncertainty pair\n            color = self(v, u)\n            # Plot color sample\n            ax.scatter([i], [0], c=[color], s=100 * size)\n            # Add value label below\n            ax.text(i, -0.2, label_format.format(v), ha=\"center\")\n\n        # Add uncertainty samples - column showing uncertainty effect\n        uncertainty_values = np.linspace(0, 1, 3)  # Show 3 uncertainty levels\n        for i, u in enumerate(uncertainty_values):\n            # Use middle value to show uncertainty effect\n            color = self(0.5, u)\n            # Plot color sample\n            ax.scatter([-1], [i], c=[color], s=100 * size)\n            # Add uncertainty label\n            ax.text(-1.5, i, label_format.format(u), ha=\"right\")\n\n        # Set up legend appearance\n        ax.set_title(title)\n        ax.set_xlim(-2, n_samples)\n        ax.set_ylim(-0.5, 2.5)\n        ax.axis(\"off\")\n\n        return ax, ax\n\n    def create_heatmap_legend(\n        self,\n        ax: Optional[plt.Axes] = None,\n    ) -&gt; Tuple[plt.Axes, plt.Axes]:\n        \"\"\"\n        Create a heatmap-style legend showing value-uncertainty combinations.\n\n        This method creates a 2D heatmap legend that shows how colors change\n        across all combinations of values and uncertainties. The x-axis represents\n        values and the y-axis represents uncertainties.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot the legend on. If None, a new figure is created.\n\n        Returns\n        -------\n        ax\n            The axes containing the heatmap legend.\n\n        Notes\n        -----\n        The number of value and uncertainty levels is determined by the\n        quantization settings:\n        - For linear quantization: n_levels for both value and uncertainty\n        - For tree quantization: branching^(n_levels-1) for value, n_levels for uncertainty\n        \"\"\"\n        if ax is None:\n            fig, ax = plt.subplots()\n\n        # Create value and uncertainty samples based on quantization settings\n        if self.quantization == \"linear\":\n            v_levels = self.n_levels\n        else:\n            v_levels = self.tree_base ** (self.n_levels - 1)\n        # Create value samples at bin centers\n        values = np.linspace(self.vmin, self.vmax, v_levels + 1)\n        # Create uncertainty samples\n        u_levels = self.n_levels\n        uncertainties = np.linspace(self.umin, self.umax, u_levels + 1)\n\n        # Create meshgrid for all value-uncertainty combinations\n        V, U = np.meshgrid(values[:-1], uncertainties[:-1])\n\n        # Get colors for all combinations\n        colors = self(V, U)\n\n        # Create heatmap\n        ax.pcolormesh(values, uncertainties, colors, shading=\"flat\")\n\n        # Add labels\n\n        ax.set_xlabel(\"Value\")\n        ax.set_ylabel(\"Uncertainty\")\n        ax.set_box_aspect(1)\n\n        return ax\n\n    def create_arcmap_legend(\n        self,\n        ax: Optional[plt.Axes] = None,\n        angular_width=90,\n        lines=False,\n        line_color=\"0.9\",\n        line_alpha=1,\n        line_width=3,\n        orient=\"down\",\n    ) -&gt; Tuple[plt.Axes, plt.Axes]:\n        \"\"\"\n        Create an arcmap-style legend showing value-uncertainty combinations using wedges.\n\n        This method creates a radial legend where:\n        - Angular position represents value\n        - Radial distance represents uncertainty\n        - Each wedge shows the color for a specific value-uncertainty combination\n\n        This layout is particularly intuitive for tree-based quantization as it\n        naturally shows the hierarchical relationship between value and uncertainty.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n            Axes to plot the legend on. If None, a new figure is created.\n        angular_width : int, optional\n            Width of the arc in degrees (default: 90)\n        lines : bool, optional\n            Whether to show grid lines (default: False)\n        line_color : str, optional\n            Color of the grid lines (default: \"0.9\")\n        line_alpha : float, optional\n            Alpha value for grid lines (default: 1)\n        line_width : float, optional\n            Width of grid lines (default: 3)\n        orient : {'up', 'left', 'down', 'right'}, optional\n            Orientation of the arc (default: 'down')\n\n        Returns\n        -------\n        ax\n            The axes containing the arcmap legend.\n        \"\"\"\n        if ax is None:\n            ax = plt.subplots(figsize=(4, 4))[1]\n\n        # Convert orientation to rotation angle\n        rotation = {\n            \"up\": 90,\n            \"left\": 180,\n            \"down\": 270,\n            \"right\": 360,\n        }[orient]\n\n        # Create radial and angular divisions\n        # Number of angular divisions depends on quantization\n        n_angular = self.tree_base ** (self.n_levels - 1)\n        value_step = (self.vmax - self.vmin) / n_angular\n        # Create value samples at bin centers\n        dummy_values = np.linspace(\n            self.vmax - value_step / 2, self.vmin + value_step / 2, n_angular\n        )\n        # Convert angular width to radians and calculate start/stop angles\n        angular_width = np.deg2rad(angular_width)\n        start_angle = np.deg2rad(rotation) - angular_width / 2\n        stop_angle = np.deg2rad(rotation) + angular_width / 2\n        angular_edges = np.linspace(start_angle, stop_angle, n_angular + 1)\n\n        # Create radial divisions for uncertainty levels\n        n_radial = self.n_levels\n        uncertainty_step = (self.umax - self.umin) / n_radial\n        # Create uncertainty samples at bin centers\n        dummy_uncertainties = np.linspace(\n            self.umax - uncertainty_step / 2, self.umin + uncertainty_step / 2, n_radial\n        )\n        radial_edges = np.linspace(0, 1, n_radial + 1)\n\n        # Create wedges for each sector\n        wedges = []\n        colors = []\n\n        # Create wedges for each value-uncertainty combination\n        for i in range(n_radial):\n            r_inner = radial_edges[i]\n            r_outer = radial_edges[i + 1]\n            uncertainty = dummy_uncertainties[i]\n\n            for j in range(n_angular):\n                theta1 = np.degrees(angular_edges[j])\n                theta2 = np.degrees(angular_edges[j + 1])\n                value = dummy_values[j]\n\n                # Create wedge for this sector\n                wedge = Wedge((0, 0), r_outer, theta1, theta2, width=r_outer - r_inner)\n                wedges.append(wedge)\n\n                # Get color for this value-uncertainty pair\n                color = self(value, uncertainty)\n                colors.append(color)\n\n        # Create patch collection for all wedges\n        collection = PatchCollection(wedges, facecolors=colors, edgecolors=\"none\")\n        ax.add_collection(collection)\n\n        if lines:\n            # Add radial grid lines (concentric arcs)\n            for r in radial_edges[1:]:\n                arc = Arc(\n                    xy=(0, 0),\n                    width=2 * r,\n                    height=2 * r,\n                    angle=0,\n                    theta1=np.rad2deg(start_angle),\n                    theta2=np.rad2deg(stop_angle),\n                    edgecolor=line_color,\n                    alpha=line_alpha,\n                    lw=line_width,\n                )\n                ax.add_artist(arc)\n\n            # Add angular grid lines (radial lines)\n            for layer in range(n_radial):\n                r0 = radial_edges[layer]\n                r1 = radial_edges[layer + 1]\n                n_div = self.tree_base**layer + 1\n                for theta in np.linspace(start_angle, stop_angle, n_div):\n                    x0 = np.cos(theta) * r0\n                    x1 = np.cos(theta) * r1\n                    y0 = np.sin(theta) * r0\n                    y1 = np.sin(theta) * r1\n                    ax.plot(\n                        [x0, x1],\n                        [y0, y1],\n                        color=line_color,\n                        alpha=line_alpha,\n                        lw=line_width,\n                    )\n\n        # Calculate offset for label positioning\n        offset = np.sin(angular_width / n_angular)\n\n        # Add uncertainty labels\n        uncertainty_labels = np.linspace(self.umax, self.umin, n_radial + 1)\n        for i, r in enumerate(radial_edges):\n            angle = angular_edges[0]\n            ha = \"left\"\n            # Position labels based on orientation\n            match orient:\n                case \"up\":\n                    x = np.cos(angle) * r + offset / 2\n                    y = np.sin(angle) * r - offset / 2\n                    labelrot = np.rad2deg(angle) - rotation\n                case \"left\":\n                    x = np.cos(angle) * r + offset / 2\n                    y = np.sin(angle) * r + offset / 2\n                    labelrot = np.rad2deg(angle) - 90\n                case \"down\":\n                    x = np.cos(angle) * r - offset / 2\n                    y = np.sin(angle) * r + offset / 2\n                    labelrot = np.rad2deg(angle) - 180\n                case \"right\":\n                    x = np.cos(angle) * r - offset / 2\n                    y = np.sin(angle) * r - offset / 2\n                    ha = \"right\"\n                    labelrot = np.rad2deg(angle) - rotation\n\n            # Add uncertainty label\n            ax.text(\n                x,\n                y,\n                f\"{uncertainty_labels[i]:.2f}\",\n                ha=ha,\n                va=\"center\",\n                rotation=labelrot,\n                rotation_mode=\"anchor\",\n            )\n\n        # Add value labels\n        value_labels = np.linspace(\n            self.vmax, self.vmin, (n_angular // self.tree_base) + 1\n        )\n        for j, angle in enumerate(angular_edges[:: self.tree_base]):\n            x = np.cos(angle) * (1 + offset)\n            y = np.sin(angle) * (1 + offset)\n            ha = \"center\"\n            va = \"center\"\n            # Position labels based on orientation\n            match orient:\n                case \"up\":\n                    labelrot = np.rad2deg(angle) - rotation\n                case \"left\":\n                    ha = \"right\"\n                    labelrot = np.rad2deg(angle) - rotation\n                case \"down\":\n                    labelrot = rotation - np.rad2deg(angle)\n                case \"right\":\n                    ha = \"left\"\n                    labelrot = rotation - np.rad2deg(angle)\n            # Add value label\n            ax.text(\n                x,\n                y,\n                f\"{value_labels[j]:.2f}\",\n                ha=ha,\n                va=va,\n                rotation=labelrot,\n                rotation_mode=\"anchor\",\n            )\n\n        # Set equal aspect ratio and limits based on orientation\n        ax.set_aspect(\"equal\")\n        r_extent = np.sin(start_angle)\n        match orient:\n            case \"up\":\n                ax.set_xlim(-r_extent * (1 + offset * 2), r_extent * (1 + offset * 2))\n                ax.set_ylim(-offset * 2, 1 + offset * 2)\n            case \"left\":\n                ax.set_xlim(-(1 + offset * 2), offset * 2)\n                ax.set_ylim(-r_extent * (1 + offset * 2), r_extent * (1 + offset * 2))\n            case \"down\":\n                ax.set_xlim(-r_extent * (1 + offset * 2), r_extent * (1 + offset * 2))\n                ax.set_ylim(-(1 + offset * 2), offset * 2)\n            case \"right\":\n                ax.set_xlim(-offset * 2, 1 + offset * 2)\n                ax.set_ylim(-r_extent * (1 + offset * 2), r_extent * (1 + offset * 2))\n\n        ax.axis(\"off\")\n        return ax\n</code></pre>"},{"location":"api/vsup/#vsup.vsup.VSUP.__call__","title":"<code>__call__(value, uncertainty)</code>","text":"<p>Map values and uncertainties to colors.</p> <p>This method is the main interface for converting value-uncertainty pairs to colors. It handles the complete pipeline: 1. Normalization of inputs to [0,1] range 2. Quantization of values and uncertainties 3. Base color mapping using the configured colormap 4. Uncertainty-based color modifications</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>array - like</code> <p>Array of values to map. Can be of any dimension.</p> required <code>uncertainty</code> <code>array - like</code> <p>Array of uncertainty values to map. Must have the same shape as value.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of RGB colors with shape (..., 3) where ... represents the input array shape. For example, if input is shape (10, 20), output will be (10, 20, 3). If input is shape (5, 6, 7), output will be (5, 6, 7, 3).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value and uncertainty arrays have different shapes</p> Source code in <code>vsup/vsup.py</code> <pre><code>def __call__(self, value: np.ndarray, uncertainty: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Map values and uncertainties to colors.\n\n    This method is the main interface for converting value-uncertainty pairs\n    to colors. It handles the complete pipeline:\n    1. Normalization of inputs to [0,1] range\n    2. Quantization of values and uncertainties\n    3. Base color mapping using the configured colormap\n    4. Uncertainty-based color modifications\n\n    Parameters\n    ----------\n    value : array-like\n        Array of values to map. Can be of any dimension.\n    uncertainty : array-like\n        Array of uncertainty values to map. Must have the same shape as value.\n\n    Returns\n    -------\n    np.ndarray\n        Array of RGB colors with shape (..., 3) where ... represents the input array shape.\n        For example, if input is shape (10, 20), output will be (10, 20, 3).\n        If input is shape (5, 6, 7), output will be (5, 6, 7, 3).\n\n    Raises\n    ------\n    ValueError\n        If value and uncertainty arrays have different shapes\n    \"\"\"\n    # Convert inputs to numpy arrays\n    value = np.atleast_1d(value)\n    uncertainty = np.atleast_1d(uncertainty)\n\n    # Validate input shapes\n    if value.shape != uncertainty.shape:\n        raise ValueError(\n            f\"value and uncertainty must have the same shape. Got value shape {value.shape} and uncertainty shape {uncertainty.shape}\"\n        )\n\n    # Store original shape for reshaping later\n    original_shape = value.shape\n\n    # Normalize values to [0,1] range\n    norm_value, norm_uncertainty = self._normalize(value, uncertainty)\n\n    # Quantize the normalized inputs\n    quantized_value, quantized_uncertainty = self.quantize(\n        norm_value, norm_uncertainty\n    )\n\n    # Get base colors from the colormap\n    base_colors = self.cmap(quantized_value)\n\n    # Apply uncertainty-based modifications with min/max constraints\n    if self.mode == \"usl\":\n        colors = usl_transform(\n            base_colors, quantized_uncertainty, smin=self.smin, lmax=self.lmax\n        )\n    elif self.mode == \"us\":\n        colors = us_transform(base_colors, quantized_uncertainty, smin=self.smin)\n    else:  # ul\n        colors = ul_transform(base_colors, quantized_uncertainty, lmax=self.lmax)\n\n    # Ensure output has correct shape (original shape + 3 for RGB)\n    if colors.shape != original_shape + (3,):\n        raise ValueError(\n            f\"Returned colors had shape {colors.shape}, expected {original_shape + (3,)}\"\n        )\n\n    return colors\n</code></pre>"},{"location":"api/vsup/#vsup.vsup.VSUP.create_arcmap_legend","title":"<code>create_arcmap_legend(ax=None, angular_width=90, lines=False, line_color='0.9', line_alpha=1, line_width=3, orient='down')</code>","text":"<p>Create an arcmap-style legend showing value-uncertainty combinations using wedges.</p> <p>This method creates a radial legend where: - Angular position represents value - Radial distance represents uncertainty - Each wedge shows the color for a specific value-uncertainty combination</p> <p>This layout is particularly intuitive for tree-based quantization as it naturally shows the hierarchical relationship between value and uncertainty.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axes to plot the legend on. If None, a new figure is created.</p> <code>None</code> <code>angular_width</code> <code>int</code> <p>Width of the arc in degrees (default: 90)</p> <code>90</code> <code>lines</code> <code>bool</code> <p>Whether to show grid lines (default: False)</p> <code>False</code> <code>line_color</code> <code>str</code> <p>Color of the grid lines (default: \"0.9\")</p> <code>'0.9'</code> <code>line_alpha</code> <code>float</code> <p>Alpha value for grid lines (default: 1)</p> <code>1</code> <code>line_width</code> <code>float</code> <p>Width of grid lines (default: 3)</p> <code>3</code> <code>orient</code> <code>(up, left, down, right)</code> <p>Orientation of the arc (default: 'down')</p> <code>'up'</code> <p>Returns:</p> Type Description <code>ax</code> <p>The axes containing the arcmap legend.</p> Source code in <code>vsup/vsup.py</code> <pre><code>def create_arcmap_legend(\n    self,\n    ax: Optional[plt.Axes] = None,\n    angular_width=90,\n    lines=False,\n    line_color=\"0.9\",\n    line_alpha=1,\n    line_width=3,\n    orient=\"down\",\n) -&gt; Tuple[plt.Axes, plt.Axes]:\n    \"\"\"\n    Create an arcmap-style legend showing value-uncertainty combinations using wedges.\n\n    This method creates a radial legend where:\n    - Angular position represents value\n    - Radial distance represents uncertainty\n    - Each wedge shows the color for a specific value-uncertainty combination\n\n    This layout is particularly intuitive for tree-based quantization as it\n    naturally shows the hierarchical relationship between value and uncertainty.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot the legend on. If None, a new figure is created.\n    angular_width : int, optional\n        Width of the arc in degrees (default: 90)\n    lines : bool, optional\n        Whether to show grid lines (default: False)\n    line_color : str, optional\n        Color of the grid lines (default: \"0.9\")\n    line_alpha : float, optional\n        Alpha value for grid lines (default: 1)\n    line_width : float, optional\n        Width of grid lines (default: 3)\n    orient : {'up', 'left', 'down', 'right'}, optional\n        Orientation of the arc (default: 'down')\n\n    Returns\n    -------\n    ax\n        The axes containing the arcmap legend.\n    \"\"\"\n    if ax is None:\n        ax = plt.subplots(figsize=(4, 4))[1]\n\n    # Convert orientation to rotation angle\n    rotation = {\n        \"up\": 90,\n        \"left\": 180,\n        \"down\": 270,\n        \"right\": 360,\n    }[orient]\n\n    # Create radial and angular divisions\n    # Number of angular divisions depends on quantization\n    n_angular = self.tree_base ** (self.n_levels - 1)\n    value_step = (self.vmax - self.vmin) / n_angular\n    # Create value samples at bin centers\n    dummy_values = np.linspace(\n        self.vmax - value_step / 2, self.vmin + value_step / 2, n_angular\n    )\n    # Convert angular width to radians and calculate start/stop angles\n    angular_width = np.deg2rad(angular_width)\n    start_angle = np.deg2rad(rotation) - angular_width / 2\n    stop_angle = np.deg2rad(rotation) + angular_width / 2\n    angular_edges = np.linspace(start_angle, stop_angle, n_angular + 1)\n\n    # Create radial divisions for uncertainty levels\n    n_radial = self.n_levels\n    uncertainty_step = (self.umax - self.umin) / n_radial\n    # Create uncertainty samples at bin centers\n    dummy_uncertainties = np.linspace(\n        self.umax - uncertainty_step / 2, self.umin + uncertainty_step / 2, n_radial\n    )\n    radial_edges = np.linspace(0, 1, n_radial + 1)\n\n    # Create wedges for each sector\n    wedges = []\n    colors = []\n\n    # Create wedges for each value-uncertainty combination\n    for i in range(n_radial):\n        r_inner = radial_edges[i]\n        r_outer = radial_edges[i + 1]\n        uncertainty = dummy_uncertainties[i]\n\n        for j in range(n_angular):\n            theta1 = np.degrees(angular_edges[j])\n            theta2 = np.degrees(angular_edges[j + 1])\n            value = dummy_values[j]\n\n            # Create wedge for this sector\n            wedge = Wedge((0, 0), r_outer, theta1, theta2, width=r_outer - r_inner)\n            wedges.append(wedge)\n\n            # Get color for this value-uncertainty pair\n            color = self(value, uncertainty)\n            colors.append(color)\n\n    # Create patch collection for all wedges\n    collection = PatchCollection(wedges, facecolors=colors, edgecolors=\"none\")\n    ax.add_collection(collection)\n\n    if lines:\n        # Add radial grid lines (concentric arcs)\n        for r in radial_edges[1:]:\n            arc = Arc(\n                xy=(0, 0),\n                width=2 * r,\n                height=2 * r,\n                angle=0,\n                theta1=np.rad2deg(start_angle),\n                theta2=np.rad2deg(stop_angle),\n                edgecolor=line_color,\n                alpha=line_alpha,\n                lw=line_width,\n            )\n            ax.add_artist(arc)\n\n        # Add angular grid lines (radial lines)\n        for layer in range(n_radial):\n            r0 = radial_edges[layer]\n            r1 = radial_edges[layer + 1]\n            n_div = self.tree_base**layer + 1\n            for theta in np.linspace(start_angle, stop_angle, n_div):\n                x0 = np.cos(theta) * r0\n                x1 = np.cos(theta) * r1\n                y0 = np.sin(theta) * r0\n                y1 = np.sin(theta) * r1\n                ax.plot(\n                    [x0, x1],\n                    [y0, y1],\n                    color=line_color,\n                    alpha=line_alpha,\n                    lw=line_width,\n                )\n\n    # Calculate offset for label positioning\n    offset = np.sin(angular_width / n_angular)\n\n    # Add uncertainty labels\n    uncertainty_labels = np.linspace(self.umax, self.umin, n_radial + 1)\n    for i, r in enumerate(radial_edges):\n        angle = angular_edges[0]\n        ha = \"left\"\n        # Position labels based on orientation\n        match orient:\n            case \"up\":\n                x = np.cos(angle) * r + offset / 2\n                y = np.sin(angle) * r - offset / 2\n                labelrot = np.rad2deg(angle) - rotation\n            case \"left\":\n                x = np.cos(angle) * r + offset / 2\n                y = np.sin(angle) * r + offset / 2\n                labelrot = np.rad2deg(angle) - 90\n            case \"down\":\n                x = np.cos(angle) * r - offset / 2\n                y = np.sin(angle) * r + offset / 2\n                labelrot = np.rad2deg(angle) - 180\n            case \"right\":\n                x = np.cos(angle) * r - offset / 2\n                y = np.sin(angle) * r - offset / 2\n                ha = \"right\"\n                labelrot = np.rad2deg(angle) - rotation\n\n        # Add uncertainty label\n        ax.text(\n            x,\n            y,\n            f\"{uncertainty_labels[i]:.2f}\",\n            ha=ha,\n            va=\"center\",\n            rotation=labelrot,\n            rotation_mode=\"anchor\",\n        )\n\n    # Add value labels\n    value_labels = np.linspace(\n        self.vmax, self.vmin, (n_angular // self.tree_base) + 1\n    )\n    for j, angle in enumerate(angular_edges[:: self.tree_base]):\n        x = np.cos(angle) * (1 + offset)\n        y = np.sin(angle) * (1 + offset)\n        ha = \"center\"\n        va = \"center\"\n        # Position labels based on orientation\n        match orient:\n            case \"up\":\n                labelrot = np.rad2deg(angle) - rotation\n            case \"left\":\n                ha = \"right\"\n                labelrot = np.rad2deg(angle) - rotation\n            case \"down\":\n                labelrot = rotation - np.rad2deg(angle)\n            case \"right\":\n                ha = \"left\"\n                labelrot = rotation - np.rad2deg(angle)\n        # Add value label\n        ax.text(\n            x,\n            y,\n            f\"{value_labels[j]:.2f}\",\n            ha=ha,\n            va=va,\n            rotation=labelrot,\n            rotation_mode=\"anchor\",\n        )\n\n    # Set equal aspect ratio and limits based on orientation\n    ax.set_aspect(\"equal\")\n    r_extent = np.sin(start_angle)\n    match orient:\n        case \"up\":\n            ax.set_xlim(-r_extent * (1 + offset * 2), r_extent * (1 + offset * 2))\n            ax.set_ylim(-offset * 2, 1 + offset * 2)\n        case \"left\":\n            ax.set_xlim(-(1 + offset * 2), offset * 2)\n            ax.set_ylim(-r_extent * (1 + offset * 2), r_extent * (1 + offset * 2))\n        case \"down\":\n            ax.set_xlim(-r_extent * (1 + offset * 2), r_extent * (1 + offset * 2))\n            ax.set_ylim(-(1 + offset * 2), offset * 2)\n        case \"right\":\n            ax.set_xlim(-offset * 2, 1 + offset * 2)\n            ax.set_ylim(-r_extent * (1 + offset * 2), r_extent * (1 + offset * 2))\n\n    ax.axis(\"off\")\n    return ax\n</code></pre>"},{"location":"api/vsup/#vsup.vsup.VSUP.create_heatmap_legend","title":"<code>create_heatmap_legend(ax=None)</code>","text":"<p>Create a heatmap-style legend showing value-uncertainty combinations.</p> <p>This method creates a 2D heatmap legend that shows how colors change across all combinations of values and uncertainties. The x-axis represents values and the y-axis represents uncertainties.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axes to plot the legend on. If None, a new figure is created.</p> <code>None</code> <p>Returns:</p> Type Description <code>ax</code> <p>The axes containing the heatmap legend.</p> Notes <p>The number of value and uncertainty levels is determined by the quantization settings: - For linear quantization: n_levels for both value and uncertainty - For tree quantization: branching^(n_levels-1) for value, n_levels for uncertainty</p> Source code in <code>vsup/vsup.py</code> <pre><code>def create_heatmap_legend(\n    self,\n    ax: Optional[plt.Axes] = None,\n) -&gt; Tuple[plt.Axes, plt.Axes]:\n    \"\"\"\n    Create a heatmap-style legend showing value-uncertainty combinations.\n\n    This method creates a 2D heatmap legend that shows how colors change\n    across all combinations of values and uncertainties. The x-axis represents\n    values and the y-axis represents uncertainties.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot the legend on. If None, a new figure is created.\n\n    Returns\n    -------\n    ax\n        The axes containing the heatmap legend.\n\n    Notes\n    -----\n    The number of value and uncertainty levels is determined by the\n    quantization settings:\n    - For linear quantization: n_levels for both value and uncertainty\n    - For tree quantization: branching^(n_levels-1) for value, n_levels for uncertainty\n    \"\"\"\n    if ax is None:\n        fig, ax = plt.subplots()\n\n    # Create value and uncertainty samples based on quantization settings\n    if self.quantization == \"linear\":\n        v_levels = self.n_levels\n    else:\n        v_levels = self.tree_base ** (self.n_levels - 1)\n    # Create value samples at bin centers\n    values = np.linspace(self.vmin, self.vmax, v_levels + 1)\n    # Create uncertainty samples\n    u_levels = self.n_levels\n    uncertainties = np.linspace(self.umin, self.umax, u_levels + 1)\n\n    # Create meshgrid for all value-uncertainty combinations\n    V, U = np.meshgrid(values[:-1], uncertainties[:-1])\n\n    # Get colors for all combinations\n    colors = self(V, U)\n\n    # Create heatmap\n    ax.pcolormesh(values, uncertainties, colors, shading=\"flat\")\n\n    # Add labels\n\n    ax.set_xlabel(\"Value\")\n    ax.set_ylabel(\"Uncertainty\")\n    ax.set_box_aspect(1)\n\n    return ax\n</code></pre>"},{"location":"api/vsup/#vsup.vsup.VSUP.create_simple_legend","title":"<code>create_simple_legend(ax=None, n_samples=5, size=1.0, title='Value', label_format='{:.1f}')</code>","text":"<p>Create a simple legend showing value colors with uncertainty levels.</p> <p>This method creates a basic legend that demonstrates how colors change with both value and uncertainty. It shows: 1. A row of color samples for different values (with no uncertainty) 2. A column of color samples showing how uncertainty affects a middle value</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axes to plot the legend on. If None, a new figure is created.</p> <code>None</code> <code>n_samples</code> <code>int</code> <p>Number of value samples to show (default: 5). These are evenly spaced across the value range.</p> <code>5</code> <code>size</code> <code>float</code> <p>Size of the legend elements (default: 1.0). This is a multiplier for the default scatter point size.</p> <code>1.0</code> <code>title</code> <code>str</code> <p>Title for the legend (default: \"Value\")</p> <code>'Value'</code> <code>label_format</code> <code>str</code> <p>Format string for value labels (default: \"{:.1f}\"). This controls how the value numbers are displayed.</p> <code>'{:.1f}'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(main_ax, legend_ax) containing the main plot axes and legend axes. These are the same axes object since this is a simple legend.</p> Source code in <code>vsup/vsup.py</code> <pre><code>def create_simple_legend(\n    self,\n    ax: Optional[plt.Axes] = None,\n    n_samples: int = 5,\n    size: float = 1.0,\n    title: str = \"Value\",\n    label_format: str = \"{:.1f}\",\n) -&gt; Tuple[plt.Axes, plt.Axes]:\n    \"\"\"\n    Create a simple legend showing value colors with uncertainty levels.\n\n    This method creates a basic legend that demonstrates how colors change\n    with both value and uncertainty. It shows:\n    1. A row of color samples for different values (with no uncertainty)\n    2. A column of color samples showing how uncertainty affects a middle value\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes, optional\n        Axes to plot the legend on. If None, a new figure is created.\n    n_samples : int, optional\n        Number of value samples to show (default: 5). These are evenly\n        spaced across the value range.\n    size : float, optional\n        Size of the legend elements (default: 1.0). This is a multiplier\n        for the default scatter point size.\n    title : str, optional\n        Title for the legend (default: \"Value\")\n    label_format : str, optional\n        Format string for value labels (default: \"{:.1f}\"). This controls\n        how the value numbers are displayed.\n\n    Returns\n    -------\n    tuple\n        (main_ax, legend_ax) containing the main plot axes and legend axes.\n        These are the same axes object since this is a simple legend.\n    \"\"\"\n    raise NotImplementedError(\"Simple legend not implemented yet\")\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(6, 4))\n\n    # Create value samples - evenly spaced across the range\n    values = np.linspace(0, 1, n_samples)\n    uncertainties = np.zeros_like(values)  # Start with no uncertainty\n\n    # Create legend elements - row of value samples\n    for i, (v, u) in enumerate(zip(values, uncertainties)):\n        # Get color for this value-uncertainty pair\n        color = self(v, u)\n        # Plot color sample\n        ax.scatter([i], [0], c=[color], s=100 * size)\n        # Add value label below\n        ax.text(i, -0.2, label_format.format(v), ha=\"center\")\n\n    # Add uncertainty samples - column showing uncertainty effect\n    uncertainty_values = np.linspace(0, 1, 3)  # Show 3 uncertainty levels\n    for i, u in enumerate(uncertainty_values):\n        # Use middle value to show uncertainty effect\n        color = self(0.5, u)\n        # Plot color sample\n        ax.scatter([-1], [i], c=[color], s=100 * size)\n        # Add uncertainty label\n        ax.text(-1.5, i, label_format.format(u), ha=\"right\")\n\n    # Set up legend appearance\n    ax.set_title(title)\n    ax.set_xlim(-2, n_samples)\n    ax.set_ylim(-0.5, 2.5)\n    ax.axis(\"off\")\n\n    return ax, ax\n</code></pre>"}]}